var path_1 = require('path');
var fs_1 = require('fs');
var extend = require('xtend');
var loader_utils_1 = require('loader-utils');
var tsconfig = require('tsconfig');
var arrify = require('arrify');
var loaderInstances = {};
var currentLoader;
function loader(content) {
    var loader = this;
    var fileName = this.resourcePath;
    var _a = getLoaderInstance(this), files = _a.files, service = _a.service;
    var file = files[fileName];
    this.cacheable();
    if (!file) {
        file = files[fileName] = { version: 0, text: '' };
    }
    file.text = content;
    file.version++;
    currentLoader = loader;
    var output = service.getEmitOutput(fileName);
    currentLoader = undefined;
    if (output.emitSkipped) {
        loader.callback(new Error("Emitting " + fileName + " failed"));
        return;
    }
    var result = output.outputFiles[loader.sourceMap ? 1 : 0].text;
    var sourceMap;
    if (loader.sourceMap) {
        sourceMap = JSON.parse(output.outputFiles[0].text);
        sourceMap.sources = [fileName];
        sourceMap.file = fileName;
        sourceMap.sourcesContent = [content];
    }
    loader.callback(null, result, sourceMap);
}
function readConfig(filename, loader, TS) {
    var config = filename ? tsconfig.readFileSync(filename) : {
        files: [],
        compilerOptions: {}
    };
    config.compilerOptions = extend({
        target: 'es5',
        module: 'commonjs'
    }, config.compilerOptions, {
        sourceMap: loader.sourceMap
    });
    return TS.parseConfigFile(config, TS.sys, filename);
}
function createInstance(loader, options) {
    var context = loader.context;
    var rootFile = loader.resourcePath;
    var files = {};
    var ignoreWarnings = arrify(options.ignoreWarnings);
    var TS = require(options.compiler || 'typescript');
    var configFile = options.configFile ?
        path_1.resolve(context, options.configFile) :
        tsconfig.resolveSync(context);
    var config = readConfig(configFile, loader, TS);
    config.errors.forEach(function (error) {
        loader.emitError(formatDiagnostic(error, TS));
    });
    var serviceHost = {
        getScriptFileNames: function () {
            return config.fileNames.concat(Object.keys(files));
        },
        getScriptVersion: function (fileName) {
            return files[fileName] && files[fileName].version.toString();
        },
        getScriptSnapshot: function (fileName) {
            var exists = fileExists(fileName);
            var file = files[fileName];
            if (exists) {
                if (!file) {
                    try {
                        file = files[fileName] = {
                            version: 0,
                            text: fs_1.readFileSync(fileName, 'utf-8')
                        };
                    }
                    catch (e) {
                        return;
                    }
                }
                if (currentLoader) {
                    currentLoader.addDependency(fileName);
                }
                return TS.ScriptSnapshot.fromString(file.text);
            }
            delete files[fileName];
        },
        getCurrentDirectory: function () { return context; },
        getScriptIsOpen: function () { return true; },
        getCompilationSettings: function () { return config.options; },
        getDefaultLibFileName: function (options) {
            return TS.getDefaultLibFilePath(config.options);
        }
    };
    var service = TS.createLanguageService(serviceHost, TS.createDocumentRegistry());
    loader._compiler.plugin('watch-run', function (watching, cb) {
        var mtimes = watching.compiler.watchFileSystem.watcher.mtimes;
        Object.keys(mtimes)
            .forEach(function (fileName) {
            var file = files[fileName];
            if (file && isDefinition(fileName)) {
                file.text = fs_1.readFileSync(fileName, 'utf8');
                file.version++;
            }
        });
        cb();
    });
    loader._compiler.plugin('emit', function (compilation, cb) {
        var program = service.getProgram();
        program.getGlobalDiagnostics()
            .concat(program.getSemanticDiagnostics())
            .forEach(function (diagnostic) {
            if (ignoreWarnings.indexOf(String(diagnostic.code)) === -1) {
                compilation.warnings.push(new DiagnosticError(diagnostic, context, TS));
            }
        });
        program.getSyntacticDiagnostics()
            .forEach(function (diagnostic) {
            compilation.errors.push(new DiagnosticError(diagnostic, context, TS));
        });
        cb();
    });
    return { service: service, files: files };
}
function fileExists(fileName) {
    try {
        return fs_1.statSync(fileName).isFile();
    }
    catch (e) {
        return false;
    }
}
function formatDiagnostic(diagnostic, TS) {
    var message = TS.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
    if (diagnostic.file) {
        var _a = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = _a.line, character = _a.character;
        return "(" + (line + 1) + "," + (character + 1) + "): " + message + " (" + diagnostic.code + ")";
    }
    return message + " (" + diagnostic.code + ")";
}
var DiagnosticError = (function () {
    function DiagnosticError(diagnostic, context, TS) {
        this.name = 'DiagnosticError';
        this.message = formatDiagnostic(diagnostic, TS);
        if (diagnostic.file) {
            this.file = loader_utils_1.urlToRequest(path_1.relative(context, diagnostic.file.fileName));
        }
    }
    return DiagnosticError;
})();
function getLoaderInstance(loader) {
    var id = loader.options.context + loader.query;
    var query = loader_utils_1.parseQuery(loader.query);
    if (loaderInstances[id]) {
        return loaderInstances[id];
    }
    var instance = createInstance(loader, query);
    loaderInstances[id] = instance;
    return instance;
}
function isDefinition(fileName) {
    return /\.d\.ts$/.test(fileName);
}
module.exports = loader;
//# sourceMappingURL=typescript-simple-loader.js.map