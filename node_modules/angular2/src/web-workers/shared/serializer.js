'use strict';var lang_1 = require("angular2/src/facade/lang");
var collection_1 = require("angular2/src/facade/collection");
var api_1 = require("angular2/src/render/api");
var change_detection_1 = require("angular2/change_detection");
var Serializer = (function () {
    function Serializer() {
    }
    Serializer.serialize = function (obj, type) {
        if (!lang_1.isPresent(obj)) {
            return null;
        }
        if (lang_1.isArray(obj)) {
            var serializedObj = [];
            collection_1.ListWrapper.forEach(obj, function (val) { serializedObj.push(Serializer.serialize(val, type)); });
            return serializedObj;
        }
        if (type == api_1.ViewDefinition) {
            return ViewDefinitionSerializer.serialize(obj);
        }
        else if (type == api_1.DirectiveBinder) {
            return DirectiveBinderSerializer.serialize(obj);
        }
        else if (type == api_1.ProtoViewDto) {
            return ProtoViewDtoSerializer.serialize(obj);
        }
        else if (type == api_1.ElementBinder) {
            return ElementBinderSerializer.serialize(obj);
        }
        else if (type == api_1.DirectiveMetadata) {
            return DirectiveMetadataSerializer.serialize(obj);
        }
        else if (type == change_detection_1.ASTWithSource) {
            return ASTWithSourceSerializer.serialize(obj);
        }
        else {
            throw "No serializer for " + type.toString();
        }
    };
    // TODO: template this to return the type that is passed if possible
    Serializer.deserialize = function (map, type, data) {
        if (!lang_1.isPresent(map)) {
            return null;
        }
        if (lang_1.isArray(map)) {
            var obj = new collection_1.List();
            collection_1.ListWrapper.forEach(map, function (val) { obj.push(Serializer.deserialize(val, type, data)); });
            return obj;
        }
        if (type == api_1.ViewDefinition) {
            return ViewDefinitionSerializer.deserialize(map);
        }
        else if (type == api_1.DirectiveBinder) {
            return DirectiveBinderSerializer.deserialize(map);
        }
        else if (type == api_1.ProtoViewDto) {
            return ProtoViewDtoSerializer.deserialize(map);
        }
        else if (type == api_1.DirectiveMetadata) {
            return DirectiveMetadataSerializer.deserialize(map);
        }
        else if (type == api_1.ElementBinder) {
            return ElementBinderSerializer.deserialize(map);
        }
        else if (type == change_detection_1.ASTWithSource) {
            return ASTWithSourceSerializer.deserialize(map, data);
        }
        else {
            throw "No deserializer for " + type.toString();
        }
    };
    Serializer.mapToObject = function (map, type) {
        var object = {};
        var serialize = lang_1.isPresent(type);
        collection_1.MapWrapper.forEach(map, function (value, key) {
            if (serialize) {
                object[key] = Serializer.serialize(value, type);
            }
            else {
                object[key] = value;
            }
        });
        return object;
    };
    /*
     * Transforms a Javascript object into a Map<string, V>
     * If the values need to be deserialized pass in their type
     * and they will be deserialized before being placed in the map
     */
    Serializer.objectToMap = function (obj, type, data) {
        if (lang_1.isPresent(type)) {
            var map = new collection_1.Map();
            collection_1.StringMapWrapper.forEach(obj, function (key, val) { map.set(key, Serializer.deserialize(val, type, data)); });
            return map;
        }
        else {
            return collection_1.MapWrapper.createFromStringMap(obj);
        }
    };
    Serializer.parser = null;
    return Serializer;
})();
exports.Serializer = Serializer;
var ASTWithSourceSerializer = (function () {
    function ASTWithSourceSerializer() {
    }
    ASTWithSourceSerializer.serialize = function (tree) {
        return { 'input': tree.source, 'location': tree.location };
    };
    ASTWithSourceSerializer.deserialize = function (obj, data) {
        // TODO: make ASTs serializable
        var ast;
        switch (data) {
            case "interpolation":
                ast = Serializer.parser.parseInterpolation(obj.input, obj.location);
                break;
            case "binding":
                ast = Serializer.parser.parseBinding(obj.input, obj.location);
                break;
            case "simpleBinding":
                ast = Serializer.parser.parseSimpleBinding(obj.input, obj.location);
                break;
            /*case "templateBindings":
              ast = Serializer.parser.parseTemplateBindings(obj.input, obj.location);
              break;*/
            case "interpolation":
                ast = Serializer.parser.parseInterpolation(obj.input, obj.location);
                break;
            default:
                throw "No AST deserializer for " + data;
        }
        return ast;
    };
    return ASTWithSourceSerializer;
})();
var ViewDefinitionSerializer = (function () {
    function ViewDefinitionSerializer() {
    }
    ViewDefinitionSerializer.serialize = function (view) {
        return {
            'componentId': view.componentId,
            'templateAbsUrl': view.templateAbsUrl,
            'template': view.template,
            'directives': Serializer.serialize(view.directives, api_1.DirectiveMetadata),
            'styleAbsUrls': view.styleAbsUrls,
            'styles': view.styles
        };
    };
    ViewDefinitionSerializer.deserialize = function (obj) {
        return new api_1.ViewDefinition({
            componentId: obj.componentId,
            templateAbsUrl: obj.templateAbsUrl, template: obj.template,
            directives: Serializer.deserialize(obj.directives, api_1.DirectiveMetadata),
            styleAbsUrls: obj.styleAbsUrls,
            styles: obj.styles
        });
    };
    return ViewDefinitionSerializer;
})();
var DirectiveBinderSerializer = (function () {
    function DirectiveBinderSerializer() {
    }
    DirectiveBinderSerializer.serialize = function (binder) {
        return {
            'directiveIndex': binder.directiveIndex,
            'propertyBindings': Serializer.mapToObject(binder.propertyBindings, change_detection_1.ASTWithSource),
            'eventBindings': Serializer.serialize(binder.eventBindings, api_1.EventBinding),
            'hostPropertyBindings': Serializer.serialize(binder.hostPropertyBindings, api_1.ElementPropertyBinding)
        };
    };
    DirectiveBinderSerializer.deserialize = function (obj) {
        return new api_1.DirectiveBinder({
            directiveIndex: obj.directiveIndex,
            propertyBindings: Serializer.objectToMap(obj.propertyBindings, change_detection_1.ASTWithSource, "binding"),
            eventBindings: Serializer.deserialize(obj.eventBindings, api_1.EventBinding),
            hostPropertyBindings: Serializer.deserialize(obj.hostPropertyBindings, api_1.ElementPropertyBinding)
        });
    };
    return DirectiveBinderSerializer;
})();
var ElementBinderSerializer = (function () {
    function ElementBinderSerializer() {
    }
    ElementBinderSerializer.serialize = function (binder) {
        return {
            'index': binder.index,
            'parentIndex': binder.parentIndex,
            'distanceToParent': binder.distanceToParent,
            'directives': Serializer.serialize(binder.directives, api_1.DirectiveBinder),
            'nestedProtoView': Serializer.serialize(binder.nestedProtoView, api_1.ProtoViewDto),
            'propertyBindings': Serializer.serialize(binder.propertyBindings, api_1.ElementPropertyBinding),
            'variableBindings': Serializer.mapToObject(binder.variableBindings),
            'eventBindings': Serializer.serialize(binder.eventBindings, api_1.EventBinding),
            'readAttributes': Serializer.mapToObject(binder.readAttributes)
        };
    };
    ElementBinderSerializer.deserialize = function (obj) {
        return new api_1.ElementBinder({
            index: obj.index,
            parentIndex: obj.parentIndex,
            distanceToParent: obj.distanceToParent,
            directives: Serializer.deserialize(obj.directives, api_1.DirectiveBinder),
            nestedProtoView: Serializer.deserialize(obj.nestedProtoView, api_1.ProtoViewDto),
            propertyBindings: Serializer.deserialize(obj.propertyBindings, api_1.ElementPropertyBinding),
            variableBindings: Serializer.objectToMap(obj.variableBindings),
            eventBindings: Serializer.deserialize(obj.eventBindings, api_1.EventBinding),
            readAttributes: Serializer.objectToMap(obj.readAttributes)
        });
    };
    return ElementBinderSerializer;
})();
var ProtoViewDtoSerializer = (function () {
    function ProtoViewDtoSerializer() {
    }
    ProtoViewDtoSerializer.serialize = function (view) {
        // TODO: fix render refs and write a serializer for them
        return {
            'render': null,
            'elementBinders': Serializer.serialize(view.elementBinders, api_1.ElementBinder),
            'variableBindings': Serializer.mapToObject(view.variableBindings),
            'textBindings': Serializer.serialize(view.textBindings, change_detection_1.ASTWithSource),
            'type': view.type
        };
    };
    ProtoViewDtoSerializer.deserialize = function (obj) {
        return new api_1.ProtoViewDto({
            render: null,
            elementBinders: Serializer.deserialize(obj.elementBinders, api_1.ElementBinder),
            variableBindings: Serializer.objectToMap(obj.variableBindings),
            textBindings: Serializer.deserialize(obj.textBindings, change_detection_1.ASTWithSource, "interpolation"),
            type: obj.type
        });
    };
    return ProtoViewDtoSerializer;
})();
var DirectiveMetadataSerializer = (function () {
    function DirectiveMetadataSerializer() {
    }
    DirectiveMetadataSerializer.serialize = function (meta) {
        var obj = {
            'id': meta.id,
            'selector': meta.selector,
            'compileChildren': meta.compileChildren,
            'hostProperties': Serializer.mapToObject(meta.hostProperties),
            'hostListeners': Serializer.mapToObject(meta.hostListeners),
            'hostActions': Serializer.mapToObject(meta.hostActions),
            'hostAttributes': Serializer.mapToObject(meta.hostAttributes),
            'properties': meta.properties,
            'readAttributes': meta.readAttributes,
            'type': meta.type,
            'exportAs': meta.exportAs,
            'callOnDestroy': meta.callOnDestroy,
            'callOnCheck': meta.callOnCheck,
            'callOnInit': meta.callOnInit,
            'callOnAllChangesDone': meta.callOnAllChangesDone,
            'changeDetection': meta.changeDetection,
            'events': meta.events
        };
        return obj;
    };
    DirectiveMetadataSerializer.deserialize = function (obj) {
        return new api_1.DirectiveMetadata({
            id: obj.id,
            selector: obj.selector,
            compileChildren: obj.compileChildren,
            hostProperties: Serializer.objectToMap(obj.hostProperties),
            hostListeners: Serializer.objectToMap(obj.hostListeners),
            hostActions: Serializer.objectToMap(obj.hostActions),
            hostAttributes: Serializer.objectToMap(obj.hostAttributes),
            properties: obj.properties,
            readAttributes: obj.readAttributes,
            type: obj.type,
            exportAs: obj.exportAs,
            callOnDestroy: obj.callOnDestroy,
            callOnCheck: obj.callOnCheck,
            callOnInit: obj.callOnInit,
            callOnAllChangesDone: obj.callOnAllChangesDone,
            changeDetection: obj.changeDetection,
            events: obj.events
        });
    };
    return DirectiveMetadataSerializer;
})();
//# sourceMappingURL=serializer.js.map